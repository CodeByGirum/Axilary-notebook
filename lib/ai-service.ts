import type { NotebookCellData, CellType } from "@/types/notebook"

export interface AIGenerationRequest {
  prompt: string
  context?: NotebookCellData[]
  targetCells?: CellType[]
}

export interface AIGenerationResponse {
  success: boolean
  cells: Partial<NotebookCellData>[]
  error?: string
}

export class AIService {
  private static instance: AIService

  static getInstance(): AIService {
    if (!AIService.instance) {
      AIService.instance = new AIService()
    }
    return AIService.instance
  }

  async generateCells(request: AIGenerationRequest): Promise<AIGenerationResponse> {
    try {
      // Simulate AI processing delay
      await this.delay(2000)

      const cells = await this.generateCellsFromPrompt(request.prompt)

      return {
        success: true,
        cells,
      }
    } catch (error) {
      return {
        success: false,
        cells: [],
        error: error instanceof Error ? error.message : "AI generation failed",
      }
    }
  }

  private async generateCellsFromPrompt(prompt: string): Promise<Partial<NotebookCellData>[]> {
    const cells: Partial<NotebookCellData>[] = []

    // Generate Markdown summary
    cells.push({
      type: "markdown",
      content: this.generateMarkdownContent(prompt),
      metadata: { title: "Analysis Summary" },
    })

    // Generate Python code if analysis is requested
    if (this.shouldGeneratePython(prompt)) {
      cells.push({
        type: "python",
        content: this.generatePythonCode(prompt),
        output: this.generatePythonOutput(prompt),
        metadata: { title: "Data Analysis" },
      })
    }

    // Generate SQL if data query is mentioned
    if (this.shouldGenerateSQL(prompt)) {
      cells.push({
        type: "sql",
        content: this.generateSQLQuery(prompt),
        metadata: { title: "Data Query" },
      })
    }

    // Generate Chart if visualization is requested
    if (this.shouldGenerateChart(prompt)) {
      cells.push({
        type: "chart",
        content: "",
        metadata: {
          title: "Data Visualization",
          chartData: { type: "bar", data: [120, 98, 76, 65, 54] },
        },
      })
    }

    // Generate R code if statistical analysis is mentioned
    if (this.shouldGenerateR(prompt)) {
      cells.push({
        type: "r",
        content: this.generateRCode(prompt),
        output: this.generateROutput(prompt),
        metadata: { title: "Statistical Analysis" },
      })
    }

    return cells
  }

  private generateMarkdownContent(prompt: string): string {
    const keywords = this.extractKeywords(prompt)

    return `# ${this.generateTitle(prompt)}

Based on your request: "${prompt}"

## Key Insights

${keywords.map((keyword) => `- Analysis of ${keyword} shows significant patterns`).join("\n")}

## Methodology

This analysis uses **data-driven approaches** to examine the requested metrics and provide actionable insights.

*Generated by AI based on your prompt*`
  }

  private generatePythonCode(prompt: string): string {
    const keywords = this.extractKeywords(prompt)
    const mainKeyword = keywords[0] || "data"

    return `import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Load and analyze ${mainKeyword}
df = pd.read_csv('${mainKeyword}.csv')

# Perform analysis
result = df.groupby('category')['value'].agg(['sum', 'mean', 'count'])
top_items = result.sort_values('sum', ascending=False).head(5)

print("Top 5 ${mainKeyword} by total value:")
print(top_items)

# Generate visualization
plt.figure(figsize=(10, 6))
top_items['sum'].plot(kind='bar')
plt.title('${this.generateTitle(prompt)}')
plt.show()`
  }

  private generatePythonOutput(prompt: string): string {
    return `Top 5 items by total value:
                sum      mean  count
Product A    120000    4800     25
Product B     98000    4900     20
Product C     76000    4750     16
Product D     65000    4333     15
Product E     54000    4500     12

Chart generated successfully.`
  }

  private generateSQLQuery(prompt: string): string {
    const keywords = this.extractKeywords(prompt)
    const table =
      keywords.find((k) => k.includes("sales") || k.includes("product") || k.includes("user")) || "data_table"

    return `SELECT 
    category,
    SUM(revenue) as total_revenue,
    COUNT(*) as item_count,
    AVG(revenue) as avg_revenue
FROM ${table}
WHERE active = 1
GROUP BY category
ORDER BY total_revenue DESC
LIMIT 5;`
  }

  private generateRCode(prompt: string): string {
    return `# Statistical analysis
data <- read.csv("data.csv")

# Summary statistics
summary(data$value)

# Correlation analysis
cor_matrix <- cor(data[, sapply(data, is.numeric)])
print(cor_matrix)

# Visualization
boxplot(value ~ category, data = data,
        main = "${this.generateTitle(prompt)}",
        xlab = "Category", ylab = "Value")`
  }

  private generateROutput(prompt: string): string {
    return `   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   12.0    45.0    67.0    68.2    89.0   145.0 

Correlation Matrix:
         value1  value2
value1   1.000   0.742
value2   0.742   1.000

Boxplot generated successfully.`
  }

  private shouldGeneratePython(prompt: string): boolean {
    const pythonKeywords = ["analyze", "analysis", "data", "calculate", "process", "algorithm", "machine learning"]
    return pythonKeywords.some((keyword) => prompt.toLowerCase().includes(keyword))
  }

  private shouldGenerateSQL(prompt: string): boolean {
    const sqlKeywords = ["query", "database", "table", "select", "data", "records", "sql"]
    return sqlKeywords.some((keyword) => prompt.toLowerCase().includes(keyword))
  }

  private shouldGenerateChart(prompt: string): boolean {
    const chartKeywords = ["chart", "graph", "plot", "visualize", "visualization", "show", "display"]
    return chartKeywords.some((keyword) => prompt.toLowerCase().includes(keyword))
  }

  private shouldGenerateR(prompt: string): boolean {
    const rKeywords = ["statistical", "statistics", "correlation", "regression", "r analysis", "statistical analysis"]
    return rKeywords.some((keyword) => prompt.toLowerCase().includes(keyword))
  }

  private extractKeywords(prompt: string): string[] {
    const words = prompt.toLowerCase().split(" ")
    const stopWords = ["the", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by", "a", "an"]
    return words.filter((word) => word.length > 3 && !stopWords.includes(word)).slice(0, 3)
  }

  private generateTitle(prompt: string): string {
    const keywords = this.extractKeywords(prompt)
    if (keywords.length > 0) {
      return `${keywords[0].charAt(0).toUpperCase() + keywords[0].slice(1)} Analysis Report`
    }
    return "Data Analysis Report"
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }
}

export const aiService = AIService.getInstance()
